---
output: 
  xaringan::moon_reader:
    lib_dir: libs
    nature:
      ratio: 16:9
      highlightStyle: github
      highlightLines: true
      countIncrementalSlides: false
---
background-image: url(www/slide1.png)
background-size: cover

<link rel="stylesheet" type="text/css" href="www/enap.css">


---

```{r setup, include=FALSE}
options(max.print = 30, digits = 4)
knitr::opts_chunk$set(fig.align = "center", fig.width = 10, fig.height = 6)
library(tidyverse)
```

# Percurso do curso

<br/>
<br/>

1. Noções de **R**

2. Ciclo da ciência de dados e tidyverse

3. União de dados

4. Lidando com textos

5. **Funções**

6. Comunicação: Gráficos

7. Comunicação: Markdown e shiny

---

# Percurso de hoje

1. Por que escrever uma função?

2. Estrutura básica

3. Argumentos

4. Corpo da função

5. Retorno

---

# Por que escrever uma função

Você pode dar um nome para a função que faça seu códgio mais fácil de entender.

Quando mudanás forem necessárias, você só precisa fazê-las uma vez, 
e não várias.

Você elimina a chance de cometer erros acidentais quando você copia e cola.
Exemplo: mudar o nome da variável em um lugar e não em outros.

---

# Quando devo escrever uma função?

```{r}
df <- tibble::tibble(
  a = rnorm(10),
  b = rnorm(10),
  c = rnorm(10),
  d = rnorm(10)
)
```

---

# Quando devo escrever uma função?

```{r}
df$a <- (df$a - min(df$a, na.rm = TRUE)) / 
  (max(df$a, na.rm = TRUE) - min(df$a, na.rm = TRUE))
df$b <- (df$b - min(df$b, na.rm = TRUE)) / 
  (max(df$b, na.rm = TRUE) - min(df$a, na.rm = TRUE))
df$c <- (df$c - min(df$c, na.rm = TRUE)) / 
  (max(df$c, na.rm = TRUE) - min(df$c, na.rm = TRUE))
df$d <- (df$d - min(df$d, na.rm = TRUE)) / 
  (max(df$d, na.rm = TRUE) - min(df$d, na.rm = TRUE))
```

---

# Quando devo escrever uma função?

```{r}
df$a <- (df$a - min(df$a, na.rm = TRUE)) / 
  (max(df$a, na.rm = TRUE) - min(df$a, na.rm = TRUE))
df$b <- (df$b - min(df$b, na.rm = TRUE)) / 
  (max(df$b, na.rm = TRUE) - min(df$a, na.rm = TRUE)) #<<
df$c <- (df$c - min(df$c, na.rm = TRUE)) / 
  (max(df$c, na.rm = TRUE) - min(df$c, na.rm = TRUE))
df$d <- (df$d - min(df$d, na.rm = TRUE)) / 
  (max(df$d, na.rm = TRUE) - min(df$d, na.rm = TRUE))
```


---

# Quando devo escrever uma função?

Regra das 3 vezes:

> Se você está fazendo algo pela terceira vez, está na hora de escrever uma função

---

# Como escrever minha função?

Primeiro, examine o código e observe quantas entradas ele tem. As entradas 
da função são o que pode mudar; as variáveis.

```{r}
(df$a - min(df$a, na.rm = TRUE)) /
  (max(df$a, na.rm = TRUE) - min(df$a, na.rm = TRUE))
```

---

# Como escrever minha função?

```{r}
x <- df$a
(x - min(x, na.rm = TRUE)) / (max(x, na.rm = TRUE) - min(x, na.rm = TRUE))
```

---

# Como escrever minha função?

Podemos remover um pouco de duplicação de código.

```{r}
rng <- range(x, na.rm = TRUE)
(x - rng[1]) / (rng[2] - rng[1])
```

---

# Como escrever minha função?

```{r}
rescale01 <- function(x) {
  rng <- range(x, na.rm = TRUE)
  (x - rng[1]) / (rng[2] - rng[1])
}
rescale01(c(0, 5, 10))
```

---

# Como escrever minha função?

Toda função tem três componentes:

1. Nome

2. Argumentos

3. Corpo

```{r}
rescale01 <-  # nome #<<
  function(x) {
  rng <- range(x, na.rm = TRUE)
  (x - rng[1]) / (rng[2] - rng[1])
}
rescale01(c(0, 5, 10))
```

---

# Como escrever minha função?

Toda função tem três componentes:

1. Nome

2. Argumentos

3. Corpo

```{r}
rescale01 <- 
  function(x) { # argumentos #<<
  rng <- range(x, na.rm = TRUE)   
  (x - rng[1]) / (rng[2] - rng[1])
}
rescale01(c(0, 5, 10))
```

---

# Como escrever minha função?

Toda função tem três componentes:

1. Nome

2. Argumentos

3. Corpo

```{r}
rescale01 <- 
  function(x) {
  rng <- range(x, na.rm = TRUE)    # corpo #<<
  (x - rng[1]) / (rng[2] - rng[1]) # corpo #<<
}
rescale01(c(0, 5, 10))
```

---

# Verificando a função

```{r}
rescale01(c(-10, 0, 10))
rescale01(c(1, 2, 3, NA, 5))
```

---

# Usando a função

```{r}
df$a <- rescale01(df$a)
df$b <- rescale01(df$b)
df$c <- rescale01(df$c)
df$d <- rescale01(df$d)
```

---

# Melhorando a função

```{r}
x <- c(1:10, Inf)
rescale01(x)
```

---

# Melhorando a função

```{r}
rescale01 <- function(x) {
  rng <- range(x, na.rm = TRUE, finite = TRUE)
  (x - rng[1]) / (rng[2] - rng[1])
}
rescale01(x)
```

---

# Exercício

---

# Lembre-se: funções são para você

## Como nomear funções

Os nomes das funções devem ser:

1. Claros quanto ao que a função faz;

2. Curtos;

3. Verbos

## Como nomear argumentos

1. Claros quanto ao seu papel na função;

2. Curtos

---

# Exercícios

---

# Execução condicional

```{r, eval = FALSE}
if (condition) {
  # code executed when condition is TRUE
} else {
  # code executed when condition is FALSE
}
```

---

# Execução condicional

```{r}
has_name <- function(x) {
  nms <- names(x)
  if (is.null(nms)) {
    rep(FALSE, length(x))
  } else {
    !is.na(nms) & nms != ""
  }
}
```

---

# Execução condicional: condição

A condição deve resultar em `TRUE` ou em `FALSE`. 
Mais de uma condição podem ser combinadas com `&` ou `|`.

```{r, error = TRUE}
if (c(TRUE, FALSE)) {}
if (NA) {}
```

---

# Execução condicional: condição

Tome cuidado com algumas comparações

```{r}
identical(0L, 0)
x <- sqrt(2) ^ 2
x
x == 2
x - 2
```

---

# Execução condicional: condição

Tome cuidado com algumas comparações. `dplyr::near()` pode ajudar.

```{r}
x <- sqrt(2) ^ 2
dplyr::near(x, 2)
```

---

# Exercícios

---

# Argumentos

Há dois tipos fundamentais de argumentos:

1. **Dados** nos quais realizar as operações

2. **Detalhes** de como fazer a função deve se comportar 

```{r}
args(log)
args(str_detect)
```

---

# Argumentos

Boas práticas:

1. **Dados** devem ser primeiros argumentos

2. **Detalhes** devem ter um padrão (usuário pode não fornecer).

---

# Argumentos

```{r}
mean_ci <- function(x, conf = 0.95) {
  se <- sd(x) / sqrt(length(x))
  alpha <- 1 - conf
  mean(x) + se * qnorm(c(alpha / 2, 1 - alpha / 2))
}
```

---

# Argumentos

```{r}
x <- runif(100)
mean_ci(x)
mean_ci(x, conf = 0.99)
```

---

# Verificação de valores

Na medida em que nos distanciamos do código que escrevemos, 
é comum esquecer seus detalhes e sutilezas. 

Como essa função funciona? O que posso e o que não posso/devo 
fazer com essa função?

Para evitar pegar o seu futuro eu na surpresa, faça as restrições da 
função explícitas.

---

# Verificação de valores

```{r}
wt_mean <- function(x, w) {
  sum(x * w) / sum(w)
}
wt_var <- function(x, w) {
  mu <- wt_mean(x, w)
  sum(w * (x - mu) ^ 2) / sum(w)
}
wt_sd <- function(x, w) {
  sqrt(wt_var(x, w))
}
```

---

# Verificação de valores

Qual o problema do código abaixo?

```{r}
wt_mean(1:6, 1:3)
```

---

# Verificação de valores

```{r}
wt_mean <- function(x, w) {
  if (length(x) != length(w)) {
    stop("`x` and `w` must be the same length", call. = FALSE)
  }
  sum(w * x) / sum(w)
}
```

---

# Verificação de valores

Quando é demais?

```{r, eval = FALSE}
wt_mean <- function(x, w, na.rm = FALSE) {
  if (!is.logical(na.rm)) {
    stop("`na.rm` must be logical")
  }
  if (length(na.rm) != 1) {
    stop("`na.rm` must be length 1")
  }
  if (length(x) != length(w)) {
    stop("`x` and `w` must be the same length", call. = FALSE)
  }
  
  ...
}
```

---

# Verificação de valores

Funções podem ser suas amigas

```{r, error = TRUE}
wt_mean <- function(x, w, na.rm = FALSE) {
  stopifnot(is.logical(na.rm), length(na.rm) == 1)
  stopifnot(length(x) == length(w))
  
  if (na.rm) {
    miss <- is.na(x) | is.na(w)
    x <- x[!miss]
    w <- w[!miss]
  }
  sum(w * x) / sum(w)
}

wt_mean(1:6, 6:1, na.rm = "foo")
```

---

# ...


E as funções que podem receber um número qualquer de argumentos?
Como elas conseguem fazer isso?

```{r}
sum(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
stringr::str_c("a", "b", "c", "d", "e", "f")
```

---

# ...

Os `...` capituram quaisquer número de argumentos que não tenham sido 
identificados como algum dos argumentos nomeados da função.


```{r}
commas <- function(...) stringr::str_c(..., collapse = ", ")
commas(letters[1:10])
```

Os `...` também podem permitir passar argumentos nomeados para outra função.

```{r}
commas(letters[1:10], letters[11:20], sep = "!")
```

---

# ...

Mas **cuidado**, argumentos com nome errado não vão gerar erros nesses casos!

```{r}
x <- c(1, 2)
sum(x, na.mr = TRUE)
```


---

# Exercícios

---

# Retorno da função

O retorno da função é a sua razão de existir.

Há duas coisas que devemos levar em conta quando decidir quando/como retornar 
o resultado da função

1. Retornar cedo pode simplificar a função?

2. Posso tornar minha função "pipeável"?

---

# Retorno da função

Por padrão o `R` retorna a ultima expressão avaliada em uma função. 
Mas se quiser fugir dessa regra podemos usar a função `return()`.

```{r}
funcao_complicada <- function(x, y, z) {
  if (length(x) == 0 || length(y) == 0) {
    return(0)
  }
    
  # Código complicado
}
```

---

# Retorno da função

```{r}
f <- function() {
  if (x) {
    # Fazer 
    # algo
    # que
    # leva
    # muitas
    # linhas
    # para
    # expressar
  } else {
    # retorna algo curto
  }
}
```

---

# Retorno da função

```{r}
f <- function() {
  if (!x) {
    return(something_short)
  }

  # Fazer 
  # algo
  # que
  # leva
  # muitas
  # linhas
  # para
  # expressar
}
```

---

# Ambientes

O `R` vai buscar os valores no ambiente em que a função foi chamada 
caso não encontre o valor dentro da própria função.

```{r}
f <- function(x) {
  x + y
}

y <- 100
f(10)

y <- 1000
f(10)
```

