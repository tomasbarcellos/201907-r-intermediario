---
output: 
  xaringan::moon_reader:
    lib_dir: libs
    nature:
      ratio: 16:9
      highlightStyle: github
      highlightLines: true
      countIncrementalSlides: false
---
background-image: url(www/slide1.png)
background-size: cover

<link rel="stylesheet" type="text/css" href="www/enap.css">


---

```{r setup, include=FALSE}
options(max.print = 30, digits = 4)
knitr::opts_chunk$set(fig.align = "center", fig.width = 10, fig.height = 6)
library(tidyverse)
```

# Percurso do curso

<br/>
<br/>

1. Noções de **R**

2. Ciclo da ciência de dados e tidyverse

3. Lidando com strings

4. Fatores e Datas

5. Funções e programação funcional

6. Comunicação: Markdown e shiny

---

# Percurso de hoje

1. Por que escrever uma função?

2. Estrutura básica

3. Argumentos

4. Corpo da função

5. Retorno

6. Boas práticas

---

# SLIDES SOBRE POR QUE ESCREVER FUNÇÕES

---

# SLIDE SOBRE FUNCOES

```{r}
library(stringr)
```

---

# Por que escrever uma função

Você pode dar um nome para a função que faça seu códgio mais fácil de entender.

Quando mudanás forem necessárias, você só precisa fazê-las uma vez, 
e não várias.

Você elimina a chance de cometer erros acidentais quando você copia e cola.
Exemplo: mudar o nome da variável em um lugar e não em outros.

---

# Quando devo escrever uma função?

```{r}
df <- tibble::tibble(
  a = rnorm(10),
  b = rnorm(10),
  c = rnorm(10),
  d = rnorm(10)
)
```

---

# Quando devo escrever uma função?

```{r}
df$a <- (df$a - min(df$a, na.rm = TRUE)) / 
  (max(df$a, na.rm = TRUE) - min(df$a, na.rm = TRUE))
df$b <- (df$b - min(df$b, na.rm = TRUE)) / 
  (max(df$b, na.rm = TRUE) - min(df$a, na.rm = TRUE))
df$c <- (df$c - min(df$c, na.rm = TRUE)) / 
  (max(df$c, na.rm = TRUE) - min(df$c, na.rm = TRUE))
df$d <- (df$d - min(df$d, na.rm = TRUE)) / 
  (max(df$d, na.rm = TRUE) - min(df$d, na.rm = TRUE))
```

---

# Quando devo escrever uma função?

```{r}
df$a <- (df$a - min(df$a, na.rm = TRUE)) / 
  (max(df$a, na.rm = TRUE) - min(df$a, na.rm = TRUE))
df$b <- (df$b - min(df$b, na.rm = TRUE)) / 
  (max(df$b, na.rm = TRUE) - min(df$a, na.rm = TRUE)) #<<
df$c <- (df$c - min(df$c, na.rm = TRUE)) / 
  (max(df$c, na.rm = TRUE) - min(df$c, na.rm = TRUE))
df$d <- (df$d - min(df$d, na.rm = TRUE)) / 
  (max(df$d, na.rm = TRUE) - min(df$d, na.rm = TRUE))
```


---

# Quando devo escrever uma função?

Regra das 3 vezes:

> Se você está fazendo algo pela terceira vez, está na hora de escrever uma função

---

# Como escrever minha função?

Primeiro, examine o código e observe quantas entradas ele tem. As entradas 
da função são o que pode mudar; as variáveis.

```{r}
(df$a - min(df$a, na.rm = TRUE)) /
  (max(df$a, na.rm = TRUE) - min(df$a, na.rm = TRUE))
```

---

# Como escrever minha função?

```{r}
x <- df$a
(x - min(x, na.rm = TRUE)) / (max(x, na.rm = TRUE) - min(x, na.rm = TRUE))
```

---

# Como escrever minha função?

Podemos remover um pouco de duplicação de código.

```{r}
rng <- range(x, na.rm = TRUE)
(x - rng[1]) / (rng[2] - rng[1])
```

---

# Como escrever minha função?

```{r}
rescale01 <- function(x) {
  rng <- range(x, na.rm = TRUE)
  (x - rng[1]) / (rng[2] - rng[1])
}
rescale01(c(0, 5, 10))
```

---

# Como escrever minha função?

Toda função tem três componentes:

1. Nome

2. Argumentos

3. Corpo

```{r}
rescale01 <-  # nome #<<
  function(x) {
  rng <- range(x, na.rm = TRUE)
  (x - rng[1]) / (rng[2] - rng[1])
}
rescale01(c(0, 5, 10))
```

---

# Como escrever minha função?

Toda função tem três componentes:

1. Nome

2. Argumentos

3. Corpo

```{r}
rescale01 <- 
  function(x) { # argumentos #<<
  rng <- range(x, na.rm = TRUE)   
  (x - rng[1]) / (rng[2] - rng[1])
}
rescale01(c(0, 5, 10))
```

---

# Como escrever minha função?

Toda função tem três componentes:

1. Nome

2. Argumentos

3. Corpo

```{r}
rescale01 <- 
  function(x) {
  rng <- range(x, na.rm = TRUE)    # corpo #<<
  (x - rng[1]) / (rng[2] - rng[1]) # corpo #<<
}
rescale01(c(0, 5, 10))
```

---

# Verificando a função

```{r}
rescale01(c(-10, 0, 10))
rescale01(c(1, 2, 3, NA, 5))
```

---

# Usando a função

```{r}
df$a <- rescale01(df$a)
df$b <- rescale01(df$b)
df$c <- rescale01(df$c)
df$d <- rescale01(df$d)
```

---

# Melhorando a função

```{r}
x <- c(1:10, Inf)
rescale01(x)
```

---

# Melhorando a função

```{r}
rescale01 <- function(x) {
  rng <- range(x, na.rm = TRUE, finite = TRUE)
  (x - rng[1]) / (rng[2] - rng[1])
}
rescale01(x)
```

---

# Exercício

1. Por que `TRUE` não é um argumento da função? O que acontece se `x` conter um 
único `NA` e `na.rm` for igual a `FALSE`.

2. Na segunda variante de `rescale01`, valores infinitos são deixados 
intocados. Altere a função para que `-Inf` vire zero e `Inf` vire 1.

3. Transforme os três trechos abaixo em funções. 
Lembre de nomear as funções com nomes significativos. 
Algo poderia ser reescrito para ser menos repetitivo?

```{r, eval = FALSE}
mean(is.na(x))

x / sum(x, na.rm = TRUE)

sd(x, na.rm = TRUE) / mean(x, na.rm = TRUE)
```

4. Escreva uma funcão `ambos_na()`, uma função que recebe dois vetores do 
mesmo tamanho e retorna o número das posições que contém `NA` em ambos vetores.

5. O que as funções abaixo fazem? Por que elas são úteis mesmo sendo tão curtas?

```{r}
is_directory <- function(x) file.info(x)$isdir
is_readable <- function(x) file.access(x, 4) == 0
```

---

# Lembre-se: funções são para você

---

# Como nomear funções

# FAZER

---

# Exercícios

1. Entenda o que as funcões abaixo fazem e dê nomes melhores a elas.

```{r}
f1 <- function(string, prefix) {
  substr(string, 1, nchar(prefix)) == prefix
}
f2 <- function(x) {
  if (length(x) <= 1) return(NULL)
  x[-length(x)]
}
f3 <- function(x, y) {
  rep(y, length.out = length(x))
}
```

2. Escolha uma das funções escritas recentemente e busque melhorar seu nome 
e o nome de seus argumentos.

---

# Execução condicional

```{r, eval = FALSE}
if (condition) {
  # code executed when condition is TRUE
} else {
  # code executed when condition is FALSE
}
```

---

# Execução condicional

```{r}
has_name <- function(x) {
  nms <- names(x)
  if (is.null(nms)) {
    rep(FALSE, length(x))
  } else {
    !is.na(nms) & nms != ""
  }
}
```

---

# Execução condicional: condição

A condição deve resultar em `TRUE` ou em `FALSE`. 
Mais de uma condição podem ser combinadas com `&` ou `|`.

```{r, error = TRUE}
if (c(TRUE, FALSE)) {}
if (NA) {}
```

---

# Execução condicional: condição

Tome cuidado com algumas comparações

```{r}
identical(0L, 0)
x <- sqrt(2) ^ 2
x
x == 2
x - 2
```

---

# Execução condicional: condição

Tome cuidado com algumas comparações. `dplyr::near()` pode ajudar.

```{r}
x <- sqrt(2) ^ 2
dplyr::near(x, 2)
```

---

# Execução condicional: condições multiplas

```{r, eval = FALSE}
if (this) {
  # do that
} else if (that) {
  # do something else
} else {
  # 
}
```

# Execução condicional: condições multiplas

O `switch()` pode ser uma forma útil de reduzir longas cadeias de if/else.

```{r}
operacao <- function(x, y, op) {
  switch(op,
         mais = x + y,
         menos = x - y,
         vezes = x * y,
         divide = x / y,
         stop("Unknown op!")
  )
}
operacao(1, 5, "mais")
operacao(3, 5, "divide")
```

---

# Exercícios

1. Qual a diferença entre `if` e `ifelse`? Leia a documentação e construa 
exemplos que ilustrem as diferenças.

2. Escreva uma função `cumprimentar` que diz "bom dia", "boa tarde" ou 
"boa noite" dependendo da hora do dia. Veja ?lubridate::now.

3. Como o uso da função `cut` pode ajudar a simplificar esta execução 
condicional (if)?

```{r, eval = FALSE}
if (temp <= 0) {
  "freezing"
} else if (temp <= 10) {
  "cold"
} else if (temp <= 20) {
  "cool"
} else if (temp <= 30) {
  "warm"
} else {
  "hot"
}
```

4. O que acontece quando usamos `switch`com valores numéricos?

---

# ---------------
# Parei no 19.5
# ---------------

